```
1. Overview
2. Component of the nf_tables
	2-1. Netlink
    2-2. table
    2-3. chain
    2-4. rule / expr
3. How nf_tables works
	3-1. nft_regs
    3-2. nft_do_chain
4. Vulnerability
5. Exploit
	4-1. Leak Kernel Base
    4-2. Hijack RIP
    4-3. Privilege Escalation
```
> 해당 글은 Linux v5.12 버전 기준으로 작성되었습니다.

# 1. Overview
---
`nf_tables`는 Linux 커널의 하위 시스템 `Netfilter`에서 동작하는 기능입니다. `Netfilter`는 Linux OS에서 패킷 필터링과 패킷 처리를 관리하는 핵심 컴포넌트이며, `nf_tables`는 이러한 `Netfilter`에서 동작하는 규칙 기반 패킷 필터링 시스템입니다.

CVE-2022-1015는 `nf_tables`에서 발생한 Stack OOB 취약점입니다. `nf_tables` 기능을 통해 네트워크 패킷에 대한 read / write를 수행하는 표현식을 추가할 때, read / write에 대한 범위 검증 과정에서 Intager Overflow가 발생하기 때문에 공격자는 취약점을 발생시키는 표현식을 추가하여 커널 Stack의 정보를 패킷 데이터에 쓰거나 패킷 데이터를 커널 스택에 쓸 수 있습니다. 

`nf_tables` 기능에 접근하기 위해서는 `CAP_NET_ADMIN` 권한이 필요합니다. 따라서 CVE-2022-1015를 트리거하기 위해서는 유저가 `namespace` 내에 격리되어 있거나, 스스로 `namespace`를 생성할 수 권한이 있어야 합니다. 일반적으로 대부분의 배포판 Linux에서는 kconfig의 `CONFIG_USER_NS`가 활성화되어 있어서, 일반 유저 권한에서 CVE-2022-1015를 통해 권한 상승 공격을 할 수 있습니다. 취약점 분석을 위해 Linux를 빌드할 경우에는 kconfig의 `CONFIG_USER_NS`를 활성화 해야합니다.

# 2. Component of the nf_tables
---
  위에서 언급했듯, `nf_tables`는 규칙 기반 패킷 필터링 시스템입니다. `nf_tables`는 `table / chain / rule / expr`라는 요소를 추가하여 규칙을 생성합니다. 유저가 네트워크 패킷 필터링 관련 명령어를 입력하면 내부적으로 패킷 필터링 규칙에 대한 `table / chain / rule / expr`가 추가됩니다. 또한 유저는 Netlink를 통해 직접 `table / chain / rule / expr`에 직접 접근할 수 있습니다.

> - **expr** : 규칙(rule)을 이루는 표현식입니다. `패킷의 포트 데이터를 reg1에 저장한다.` 이와 같은 단순한 동작을 정의하며, 이러한 표현식들이 모여 하나의 규칙을 이룹니다.
> - **rule** : 다수의 expr를 이용하여 규칙(rule)을 만들 수 있습니다. 이러한 규칙은 chain
> - **chain** : rule과 Hook 데이터로 구성되어 있습니다. Hook 데이터는 어느 시점에서 패킷 필터링을 수행할지를 결정합니다. (예 : 패킷을 전송할 때 or 패킷을 수신할 때) 해당 시점에서 `nf_tables`는 chain에 담긴 rule을 통해 expr를 일렬로 실행합니다.
> - **table** : chain을 저장하고 있으며, 패킷 필터링이 동작할 네트워크 계층 프로토콜(ipv4, ipv6, arp 등)을 지정합니다.
 
에를 들어, 5000번 포트 TCP 패킷을 드랍하는 규칙을 적용한다면, `nf_tables`의 구조는 아래와 같아집니다.

```bash
table <table_name : table1, proto : NFPROTO_IPV4>
	-> chain <chain_name : chain1, hook : NF_INET_LOCAL_IN>
    	-> rule
        	-> expr : NFT_REG_1 = *(&PKT + NFT_PAYLOAD_NETWORK_HEADER + offsetof(protocol))
            -> expr : CMP NFT_REG_1 == IPPROTO_TCP
            -> expr : NFT_REG_1 = *(&PKT + NFT_PAYLOAD_NETWORK_HEADER + offsetof(dest))
    		-> expr : CMP NFT_REG_1 == htons(5000)
            -> expr : DROP
```
expr는 실제로 payload(패킷 데이터 레지스터에 쓰기), set_payload(레지스터를 패킷 데이터에 쓰기), cmp(레지스터 비교) 같은 함수 단위로 이루어져있습니다.

## 2-1. Netlink

`Netlink`는 유저가 커널에 네트워크 정보를 전달하기 위해 사용되는 인터페이스입니다. 즉, 사용자는 `Netlink`를 통해 `nf_tables`와 상호작용하여 `table / chain / rule / expr`와 같은 요소들을 생성하고 추가할 수 있습니다.

> - https://git.netfilter.org/libnftnl/tree/examples/nft-table-add.c
> - https://git.netfilter.org/libnftnl/tree/examples/nft-chain-add.c
> - https://git.netfilter.org/libnftnl/tree/examples/nft-rule-add.c
 
위 링크에서 Netlink를 통해 `table / chain / rule / expr`를 추가하는 예제 코드를 찾을 수 있습니다.

위와 같이 libmnl 및 libnftnl 라이브러리를 통해 유저레벨에서 Netlink를 이용하는 코드를 만들 수 있습니다. 해당 라이브러리들은 static 컴파일을 지원하지 않기 때문에 라이브러리를 대상 커널로 복사해주어야 합니다.

```c
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch),
				    NFT_MSG_NEWTABLE, family,
				    NLM_F_CREATE | NLM_F_ACK, seq++);
```
nft-table-add.c 코드를 보면 추가할 Table 데이터와 함께 `NFT_MSG_NEWTABLE` 값으로 `Netlink Message`를 만들어 전송합니다. 전송된 `Netlink Message`는 커널의 [nfnetlink_rcv](https://github.com/torvalds/linux/blob/v5.12/net/netfilter/nfnetlink.c#L583) 함수가 수신합니다. 이후 `Netlink Message`는 오류 검증을 위해 해당 `Netlink Message`의 동작이 이전에 실행된 적이 없을 경우 `nfnetlink_rcv_skb_batch` 함수, 이전에 한번 이상 실행된 동작일 경우 `netlink_rcv_skb`->`nfnetlink_rcv_msg` 함수에 의해 처리됩니다. 

https://github.com/torvalds/linux/blob/v5.12/net/netfilter/nfnetlink.c#L252
```c
err = nc->call(net, net->nfnl, skb, nlh,
	(const struct nlattr **)cda,
	extack);
```
이후 해당 코드를 통해 `Netlink Message`에 담긴 동작이 실행됩니다. 이때 `nc` 변수는 `nfnl_callback` 구조체이며, 아래와 같이 정의되어있습니다.

https://github.com/torvalds/linux/blob/master/net/netfilter/nf_tables_api.c#L8920
```c
static const struct nfnl_callback nf_tables_cb[NFT_MSG_MAX] = {
	[NFT_MSG_NEWTABLE] = {
		.call		= nf_tables_newtable,
		.type		= NFNL_CB_BATCH,
		.attr_count	= NFTA_TABLE_MAX,
		.policy		= nft_table_policy,
	},
	[NFT_MSG_GETTABLE] = {
		.call		= nf_tables_gettable,
		.type		= NFNL_CB_RCU,
		.attr_count	= NFTA_TABLE_MAX,
		.policy		= nft_table_policy,
	},
	[NFT_MSG_DELTABLE] = {
		.call		= nf_tables_deltable,
		.type		= NFNL_CB_BATCH,
		.attr_count	= NFTA_TABLE_MAX,
		.policy		= nft_table_policy,
	},
    ...
```
즉, `Netlink Message`에 담긴 `NFT_MSG_NEWTABLE` 값을 통해 `nf_tables_newtable` 함수가 호출되어 `nf_tables`에 table을 생성하는 작업이 진행됩니다.

## 2-2. table

```c
static struct nftnl_table *table_add_parse(int argc, char *argv[])
{
	struct nftnl_table *t;
	uint16_t family;

	if (strcmp(argv[1], "ip") == 0)
		family = NFPROTO_IPV4;
	else if (strcmp(argv[1], "ip6") == 0)
		family = NFPROTO_IPV6;
	else if (strcmp(argv[1], "inet") == 0)
		family = NFPROTO_INET;
	else if (strcmp(argv[1], "bridge") == 0)
		family = NFPROTO_BRIDGE;
	else if (strcmp(argv[1], "arp") == 0)
		family = NFPROTO_ARP;
	else {
		fprintf(stderr, "Unknown family: ip, ip6, inet, bridge, arp\n");
		return NULL;
	}

	t = nftnl_table_alloc();
	if (t == NULL) {
		perror("OOM");
		return NULL;
	}

	nftnl_table_set_u32(t, NFTNL_TABLE_FAMILY, family);
	nftnl_table_set_str(t, NFTNL_TABLE_NAME, argv[2]);

	return t;
}
```
nft-table-add.c 코드를 통해 table에 어떠한 요소가 들어가는지 알 수 있습니다. `NFTNL_TABLE_NAME`은 table의 이름을 의미하며, `NFTNL_TABLE_FAMILY`는 해당 table에 추가될 chain이 어떤 네트워크 계층 프로토콜의 패킷을 필터링 할지를 결정합니다.

## 2-3. chain
```c
static struct nftnl_chain *chain_add_parse(int argc, char *argv[])
{
	struct nftnl_chain *t;
	int hooknum = 0;

	if (argc == 6) {
		/* This is a base chain, set the hook number */
		if (strcmp(argv[4], "NF_INET_LOCAL_IN") == 0)
			hooknum = NF_INET_LOCAL_IN;
		else if (strcmp(argv[4], "NF_INET_LOCAL_OUT") == 0)
			hooknum = NF_INET_LOCAL_OUT;
		else if (strcmp(argv[4], "NF_INET_PRE_ROUTING") == 0)
			hooknum = NF_INET_PRE_ROUTING;
		else if (strcmp(argv[4], "NF_INET_POST_ROUTING") == 0)
			hooknum = NF_INET_POST_ROUTING;
		else if (strcmp(argv[4], "NF_INET_FORWARD") == 0)
			hooknum = NF_INET_FORWARD;
		else {
			fprintf(stderr, "Unknown hook: %s\n", argv[4]);
			return NULL;
		}
	}

	t = nftnl_chain_alloc();
	if (t == NULL) {
		perror("OOM");
		return NULL;
	}
	nftnl_chain_set_str(t, NFTNL_CHAIN_TABLE, argv[2]);
	nftnl_chain_set_str(t, NFTNL_CHAIN_NAME, argv[3]);
	if (argc == 6) {
		nftnl_chain_set_u32(t, NFTNL_CHAIN_HOOKNUM, hooknum);
		nftnl_chain_set_u32(t, NFTNL_CHAIN_PRIO, atoi(argv[5]));
	}

	return t;
}
```
nft-table-chain.c 코드를 통해 알 수 있는 chain의 요소는 다음과 같습니다. 먼저, `NFTNL_CHAIN_TABLE`은 chain이 추가될 table의 이름입니다. `NFTNL_CHAIN_NAME`은 해당 chain의 이름이며, `NFTNL_CHAIN_HOOKNUM`은 chain이 동작할 Hook의 위치를 의미합니다. 즉, 어느 시점에서 패킷 필터링을 수행할지를 결정하는 값입니다.

IPv4에서 `NFTNL_CHAIN_HOOKNUM`의 종류는 아래와 같습니다.
> - NF_INET_PRE_ROUTING
> - NF_INET_LOCAL_IN
> - NF_INET_FORWARD
> - NF_INET_LOCAL_OUT
> - NF_INET_POST_ROUTING

예를 들어 `NFTNL_CHAIN_HOOKNUM`이 `NF_INET_LOCAL_IN`일 경우 패킷이 로컬로 수신되었을때, `nf_tables`는 해당 chain에 저장된 rule대로 패킷을 필터링합니다.

`NFTNL_CHAIN_PRIO`는 chain의 우선도를 결정합니다. 하나의 table에는 여러개의 chain을 추가할 수 있기 때문에, `NFTNL_CHAIN_PRIO`를 통해서 어떤 chain이 먼저 동작하게 할지를 정할 수 있습니다.

## 2-4. rule / expr
```c
static struct nftnl_rule *setup_rule(uint8_t family, const char *table,
				   const char *chain, const char *handle)
{
	struct nftnl_rule *r = NULL;
	uint8_t proto;
	uint16_t dport;
	uint64_t handle_num;

	r = nftnl_rule_alloc();
	if (r == NULL) {
		perror("OOM");
		exit(EXIT_FAILURE);
	}

	nftnl_rule_set_str(r, NFTNL_RULE_TABLE, table);
	nftnl_rule_set_str(r, NFTNL_RULE_CHAIN, chain);
	nftnl_rule_set_u32(r, NFTNL_RULE_FAMILY, family);

	if (handle != NULL) {
		handle_num = atoll(handle);
		nftnl_rule_set_u64(r, NFTNL_RULE_POSITION, handle_num);
	}

	proto = IPPROTO_TCP;
	add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1,
		    offsetof(struct iphdr, protocol), sizeof(uint8_t));
	add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &proto, sizeof(uint8_t));

	dport = htons(22);
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_1,
		    offsetof(struct tcphdr, dest), sizeof(uint16_t));
	add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &dport, sizeof(uint16_t));

	add_counter(r);

	return r;
}
```
nft-table-add.c 코드입니다. `NFTNL_RULE_TABLE`, `NFTNL_RULE_CHAIN`은 각각 해당 rule이 추가 될 table과 chain의 이름입니다.

`add_payload`, `add_cmp`는 각각 expr를 추가하는 함수입니다. expr는 여러가지가 존재하지만, 여기에서는 기본적인 expr에 대해서만 설명합니다.

### 1. payload
```c
static void add_payload(struct nftnl_rule *r, uint32_t base, uint32_t dreg,
			uint32_t offset, uint32_t len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("payload");
	if (e == NULL) {
		perror("expr payload oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_BASE, base);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_DREG, dreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_OFFSET, offset);
	nftnl_expr_set_u32(e, NFTNL_EXPR_PAYLOAD_LEN, len);

	nftnl_rule_add_expr(r, e);
}
```
해당 expr는 패킷의 데이터를 레지스터에 복사(write)하는 동작을 합니다. 총 4개의 인자를 가지며, 각 인자를 아래와 같은 의미입니다.

> - NFTNL_EXPR_PAYLOAD_BASE : 패킷의 어떤 구조에서 시작할지 결정합니다.
> - NFTNL_EXPR_PAYLOAD_DREG : 어떤 레지스터에 데이터를 복사할지 결정합니다.
> - NFTNL_EXPR_PAYLOAD_OFFSET : 복사할 데이터의 offset을 결정합니다.
> - NFTNL_EXPR_PAYLOAD_LEN : 어느 길이만큼 데이터를 복사할지 결정합니다.

```c
add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1,
		    offsetof(struct iphdr, protocol), sizeof(uint8_t));
```
위 코드는 `NFT_PAYLOAD_NETWORK_HEADER`를 기준으로 `offsetof(struct iphdr, protocol)`만큼 떨어진 데이터를 `sizeof(uint8_t)`만큼 `NFT_REG_1`에 복사하는 표현식을 추가합니다. 즉, 해당 패킷의 protocol 정보를 `NFT_REG_1`에 저장하는 기록하는 동작을 합니다.

### 2. set_payload
payload 표현식이 패킷의 데이터를 NFT 레지스터에 복사하는 역할을 한다면, set_payload 표현식은 반대로 NFT 레지스터의 데이터를 패킷에 복사합니다.

payload 표현식을 추가하는 코드에서 `NFTNL_EXPR_PAYLOAD_DREG`를 `NFTNL_EXPR_PAYLOAD_SREG`로 바꾸어주면 set_payload 표현식을 추가할 수 있습니다.

### 3. cmp
```c
static void add_cmp(struct nftnl_rule *r, uint32_t sreg, uint32_t op,
		    const void *data, uint32_t data_len)
{
	struct nftnl_expr *e;

	e = nftnl_expr_alloc("cmp");
	if (e == NULL) {
		perror("expr cmp oom");
		exit(EXIT_FAILURE);
	}

	nftnl_expr_set_u32(e,  `NFTNL_EXPR_CMP_SREG` , sreg);
	nftnl_expr_set_u32(e, NFTNL_EXPR_CMP_OP, op);
	nftnl_expr_set(e, NFTNL_EXPR_CMP_DATA, data, data_len);

	nftnl_rule_add_expr(r, e);
}
```
cmp는 레지스터 값을 비교하는 표현식입니다. `NFTNL_EXPR_CMP_SREG`를 비교대상 레지스터를, `NFTNL_EXPR_CMP_OP` 비교 연산의 종류를, `NFTNL_EXPR_CMP_DATA`는 비교할 값과 그 값의 길이를 정합니다.

비교 연산의 종류는 여러가지가 있지만 대표적으로 아래와 같습니다.
> - NFT_CMP_EQ : 두 비교 대상이 같을 경우
> - NFT_CMP_NEQ : 두 비교 대상이 다를 경우

CMP의 비교 연산을 만족할 경우 그 다음 expr가 실행되며, 만족하지 않을 경우 해당 chain에 다음 expr를 모두 건너뜁니다.

```c
proto = IPPROTO_TCP;
add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &proto, sizeof(uint8_t));
```
위 코드는 NFT_REG_1 레지스터를 IPPROTO_TCP 값과 같은지(NFT_CMP_EQ) 비교합니다.

<br/><br/>
```c
	proto = IPPROTO_TCP;
	add_payload(r, NFT_PAYLOAD_NETWORK_HEADER, NFT_REG_1,
		    offsetof(struct iphdr, protocol), sizeof(uint8_t));
	add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &proto, sizeof(uint8_t));

	dport = htons(22);
	add_payload(r, NFT_PAYLOAD_TRANSPORT_HEADER, NFT_REG_1,
		    offsetof(struct tcphdr, dest), sizeof(uint16_t));
	add_cmp(r, NFT_REG_1, NFT_CMP_EQ, &dport, sizeof(uint16_t));

	add_counter(r);
   ```
expr들을 이해했다면, 위에 nft-rule-add.c 코드가 어떤 rule을 추가하는지 알 수 있습니다. 

1. `NFT_PAYLOAD_NETWORK_HEADER`를 기준으로 `offsetof(struct iphdr, protocol)` 오프셋 만큼 떨어진 곳에 패킷 데이터를 `NFT_REG_1`에 1바이트 복사합니다. (프로토콜 정보를 `NFT_REG_1`에 저장)

2. `NFT_REG_1`의 값이 `IPPROTO_TCP`인지 비교합니다. (TCP 패킷인지 체크)

3. `NFT_PAYLOAD_NETWORK_HEADER`를 기준으로 `offsetof(struct tcphdr, dest)` 오프셋 만큼 떨어진 곳에 패킷 데이터를 `NFT_REG_1`에 2바이트 복사힙니다. (port 정보를 NFT_REG_1에 저장)

4. `NFT_REG_1`의 값이 `htons(22)`인지 비교합니다. (패킷의 포트가 22번 인지 비교) 

5. counter expr를 이용해서 counter를 올립니다.

즉, 22번 포트의 TCP 패킷을 감지하여 counter를 올리는 규칙입니다. counter 표현식은 익스플로잇에 필요없기 때문에 여기에서 설명하지는 않겠습니다.

# 3. How nf_tables works
`table / chain / rule / expr`를 통해 정의된 패킷 필터링 규칙은 `nft_regs` 구조체와 `nft_do_chain` 함수에 의해 처리됩니다. `nft_do_chain` 함수는 각 chain을 가져와 rule에 담긴 일렬의 expr들을 차례대로 실행하며, expr는 정해진대로 `nft_regs`에 값을 쓰거나 비교합니다. 

## 3-1. nft_regs
위에서 expr를 분석하면 알 수 있듯이, `nf_tables`는 패킷을 처리하는 과정에서 여러 레지스터를 이용합니다.
https://github.com/torvalds/linux/blob/master/include/net/netfilter/nf_tables.h#L119
```c
enum nft_registers {
	NFT_REG_VERDICT,
	NFT_REG_1,
	NFT_REG_2,
	NFT_REG_3,
	NFT_REG_4,
	__NFT_REG_MAX,
	NFT_REG32_00	= 8,
	NFT_REG32_01,
	...
	NFT_REG32_15,
};

struct nft_verdict {
	u32				code;
	struct nft_chain		*chain;
};

struct nft_regs {
	union {
		u32			data[20];
		struct nft_verdict	verdict;
	};
};
```
`nft_regs`는 4바이트의 `NFT_REG32_0 ~ NFT_REG32_15`와 `NFT_REG_VERDICT`로 이루어져있습니다. 이때 정의된 `nft_registers` 열거를 보면 `NFT_REG32_0 ~ NFT_REG32_15` 이외에도 `NFT_REG_1 ~ NFT_REG_4`가 있는 것을 알 수 있습니다. 이들은 16바이트 레지스터로, `NFT_REG_1`은 `NFT_REG32_0 ~ NFT_REG32_3`, `NFT_REG_2`는 `NFT_REG32_4 ~ NFT_REG32_7`과 대응됩니다.

`NFT_REG_VERDICT`는 판정 레지스터로, 예를 들어 cmp expr에서 비교 연산 결과가 False라면 `nft_verdict->code` 변수에 `NFT_BREAK` 값을 대입합니다. 그러면 이후 `nft_do_chain` 함수에서 `nft_verdict->code` 값을 체크하여 `NFT_BREAK`일 경우 break를 실행하여 다음 expr를 건너뜁니다. 이외에도 chain의 흐름을 조작할 수 있는 특정 expr에서 `nft_verdict->code` 변수에 `NFT_GOTO`를 대입하고, `nft_verdict->chain`에 점프할 chain을 대입하면, `nft_do_chain`는 `nft_verdict->chain`에 저장된 chain으로 점프하게 됩니다. 이렇듯 `NFT_REG_VERDICT`는 chain의 흐름을 조작하는 레지스터입니다.

## 3-2. nft_do_chain
https://github.com/torvalds/linux/blob/v5.12/net/netfilter/nf_tables_core.c#L158
```c
nft_do_chain(struct nft_pktinfo *pkt, void *priv)
{
	const struct nft_chain *chain = priv, *basechain = chain;
	const struct net *net = nft_net(pkt);
	struct nft_rule *const *rules;
	const struct nft_rule *rule;
	const struct nft_expr *expr, *last;
	struct nft_regs regs;
	unsigned int stackptr = 0;
	struct nft_jumpstack jumpstack[NFT_JUMP_STACK_SIZE];
	bool genbit = READ_ONCE(net->nft.gencursor);
	struct nft_traceinfo info;

	...
    
	rule = *rules;
	regs.verdict.code = NFT_CONTINUE;
	for (; *rules ; rules++) {
		rule = *rules;
		nft_rule_for_each_expr(expr, last, rule) {
			if (expr->ops == &nft_cmp_fast_ops)
				nft_cmp_fast_eval(expr, &regs);
			else if (expr->ops == &nft_bitwise_fast_ops)
				nft_bitwise_fast_eval(expr, &regs);
			else if (expr->ops != &nft_payload_fast_ops ||
				 !nft_payload_fast_eval(expr, &regs, pkt))
				expr_call_ops_eval(expr, &regs, pkt);

			if (regs.verdict.code != NFT_CONTINUE)
				break;
		}

		switch (regs.verdict.code) {
		case NFT_BREAK:
			regs.verdict.code = NFT_CONTINUE;
			continue;
		case NFT_CONTINUE:
			nft_trace_packet(&info, chain, rule,
					 NFT_TRACETYPE_RULE);
			continue;
		}
		break;
	}

	switch (regs.verdict.code & NF_VERDICT_MASK) {
	case NF_ACCEPT:
	case NF_DROP:
	case NF_QUEUE:
	case NF_STOLEN:
		nft_trace_packet(&info, chain, rule,
				 NFT_TRACETYPE_RULE);
		return regs.verdict.code;
	}

	switch (regs.verdict.code) {
	case NFT_JUMP:
		if (WARN_ON_ONCE(stackptr >= NFT_JUMP_STACK_SIZE))
			return NF_DROP;
		jumpstack[stackptr].chain = chain;
		jumpstack[stackptr].rules = rules + 1;
		stackptr++;
		fallthrough;
	case NFT_GOTO:
		nft_trace_packet(&info, chain, rule,
				 NFT_TRACETYPE_RULE);

		chain = regs.verdict.chain;
		goto do_chain;
	case NFT_CONTINUE:
	case NFT_RETURN:
		nft_trace_packet(&info, chain, rule,
				 NFT_TRACETYPE_RETURN);
		break;
	default:
		WARN_ON(1);
	}

	...
    
}
```
chain을 추가할때 설정한 `NFTNL_CHAIN_HOOKNUM`에 의하여 특정 시점에 후킹 함수가 실행되면, 최종적으로 `nft_do_chain` 함수에 도달하여 해당 chain의 expr를 차례대로 수행합니다. `nft_do_chain`의 코드를 보면 알 수 있듯이, chain에서 rule 데이터를 가져오고 해당 rule에 추가되어 있는 expr들을 차례대로 순회하며 `expr_call_ops_eval` 함수를 실행합니다. 이후 판정 레지스터(`NFT_REG_VERDICT`)를 체크하며 흐름을 제어합니다.

https://github.com/torvalds/linux/blob/v5.12/net/netfilter/nf_tables_core.c#L132
```c
static void expr_call_ops_eval(const struct nft_expr *expr,
			       struct nft_regs *regs,
			       struct nft_pktinfo *pkt)
{
#ifdef CONFIG_RETPOLINE
	unsigned long e = (unsigned long)expr->ops->eval;
#define X(e, fun) \
	do { if ((e) == (unsigned long)(fun)) \
		return fun(expr, regs, pkt); } while (0)

	X(e, nft_payload_eval);
	X(e, nft_cmp_eval);
	X(e, nft_meta_get_eval);
	X(e, nft_lookup_eval);
	X(e, nft_range_eval);
	X(e, nft_immediate_eval);
	X(e, nft_byteorder_eval);
	X(e, nft_dynset_eval);
	X(e, nft_rt_get_eval);
	X(e, nft_bitwise_eval);
#undef  X
#endif /* CONFIG_RETPOLINE */
	expr->ops->eval(expr, regs, pkt);
}
```
`expr_call_ops_eval`함수는 실제 expr의 동작을 수행하는 함수를 호출하는 역할을 합니다. 인자로 주어진 expr가 cmp라면 `nft_cmp_eval` 함수를, payload라면, `nft_payload_eval` 함수를 호출합니다. 따라서 특정 expr의 동작을 디버깅하고 싶다면 `expr_call_ops_eval`에서 실제 동작을 수행하는 함수가 어떤 함수인지를 찾은 다음 그곳에 Breakpoint를 걸면 됩니다.

# 4. Vulnerability
https://github.com/torvalds/linux/blob/v5.12/net/netfilter/nf_tables_api.c#L8725
```c
static unsigned int nft_parse_register(const struct nlattr *attr)
{
	unsigned int reg;

	reg = ntohl(nla_get_be32(attr));
	switch (reg) {
	case NFT_REG_VERDICT...NFT_REG_4:
		return reg * NFT_REG_SIZE / NFT_REG32_SIZE;
	default:
		return reg + NFT_REG_SIZE / NFT_REG32_SIZE - NFT_REG32_00;
	}
}

...

static int nft_validate_register_load(enum nft_registers reg, unsigned int len)
{
	if (reg < NFT_REG_1 * NFT_REG_SIZE / NFT_REG32_SIZE)
		return -EINVAL;
	if (len == 0)
		return -EINVAL;
	if (reg * NFT_REG32_SIZE + len > sizeof_field(struct nft_regs, data))
		return -ERANGE;

	return 0;
}

int nft_parse_register_load(const struct nlattr *attr, u8 *sreg, u32 len)
{
	u32 reg;
	int err;

	reg = nft_parse_register(attr);
	err = nft_validate_register_load(reg, len);
	if (err < 0)
		return err;

	*sreg = reg;
	return 0;
}
```
